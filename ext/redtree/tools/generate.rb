# $Id: generate.rb 25189 2009-10-02 12:04:37Z akr $

require 'optparse'
require 'set'

def main
  mode = nil
  ids1src = nil
  ids2src = nil
  ripper_src = nil
  template = nil
  output = nil

  parser = @parser = OptionParser.new
  parser.banner = "Usage: #{File.basename($0)} --mode=MODE [--ids1src=PATH] [--ids2src=PATH] [--ripper-ids=PATH] [--output=PATH]"
  parser.on('--mode=MODE', 'check, eventids1, eventids2table, ripperids.') {|m|
    mode = m
  }
  parser.on('--ids1src=PATH', 'A source file of event-IDs 1 (parse.y).') {|path|
    ids1src = path
  }
  parser.on('--ids2src=PATH', 'A source file of event-IDs 2 (eventids2.c).') {|path|
    ids2src = path
  }
  parser.on('--ripper-ids=PATH', 'A source file for ripper IDs (to_ripper.c).') {|path|
    ripper_src = path
  }
  parser.on('--output=PATH', 'An output file.') {|path|
    output = path
  }
  parser.on('--help', 'Prints this message and quit.') {
    puts parser.help
    exit true
  }
  begin
    parser.parse!
  rescue OptionParser::ParseError => err
    usage err.message
  end
  usage 'no mode given' unless mode
  case mode
  when 'check'
    usage 'no --ids1src' unless ids1src
    h = read_ids1(ids1src)
    ids2 = read_ids2(ids2src)
    common = h & ids2
    unless common.empty?
      abort "event crash: #{common.join(' ')}"
    end
    exit 0
  when 'eventids1'
    usage 'no --ids1src' unless ids1src
    result = generate_eventids1(read_ids1(ids1src))
  when 'eventids2table'
    usage 'no --ids2src' unless ids2src
    result = generate_eventids2_table(read_ids2(ids2src), read_tokens(ids2src))
  when 'ripperids'
    usage 'no --ripper-ids' unless ripper_src
    result = generate_ripper_eventids(read_ripper_ids(ripper_src))
  end
  if output
    File.open(output, 'w') {|f|
      f.write result
    }
  else
    puts result
  end
end

def usage(msg)
  $stderr.puts msg
  $stderr.puts @parser.help
  exit false
end

def camelize(lower_case_and_underscored_word)
  lower_case_and_underscored_word.to_s.gsub(/\/(.?)/) { "::#{$1.upcase}" }.gsub(/(?:^|_)(.)/) { $1.upcase }
end

def constant_name_for_id(id)
  id.split('__').map { |part| camelize(part) }.join('_')
end

def generate_eventids1(ids)
  buf = "// DO NOT DIRECTLY EDIT THIS FILE! Autogenerated by tools/generate.rb --ids1src\n"
  buf << "enum redtree_ids {\n"
  ids.each do |id|
    buf << "  redtree_rulenum_#{id},\n"
  end
  buf << "};\n\n"
  buf << "static void\n"
  buf << "redtree_init_eventids1(VALUE self) {\n"
  buf << %Q[  rb_aNames = rb_ary_new2(redtree_rulenum_MAX_RULES);\n]
  buf << %Q[  rb_define_const(rb_cNode, "NAMES", rb_aNames);\n]

  ids.each do |id|
    constant_name = constant_name_for_id(id)
    buf << %Q[  rb_define_const(rb_cNode, "#{constant_name}", INT2FIX(redtree_rulenum_#{id}));\n]
    buf << %Q[  rb_ary_push(rb_aNames, ID2SYM(rb_intern_const("#{constant_name}")));\n]
  end

  buf << "}\n"
  buf
end

def generate_ripper_eventids(ids)
  buf = ""
  ids.each do |id, arity|
    buf << %Q[static ID ripper_id_#{id};\n]
  end
  buf << %Q[\n]
  buf << %Q[static void\n]
  buf << %Q[redtree_init_ripperids(VALUE self)\n]
  buf << %Q[{\n]
  buf << %Q[    VALUE h;\n]
  buf << %Q[    ID id;\n]
  ids.each do |id, arity|
    buf << %Q[    ripper_id_#{id} = rb_intern_const("on_#{id}");\n]
  end
  buf << %Q[\n]
  buf << %Q[    h = rb_hash_new();\n]
  buf << %Q[    rb_define_const(self, "PARSER_EVENT_TABLE", h);\n]
  ids.each do |id, arity|
    buf << %Q[    id = rb_intern_const("#{id}");\n]
    buf << %Q[    rb_hash_aset(h, ID2SYM(id), INT2NUM(#{arity}));\n]
  end
  buf << %Q[}\n]
  buf
end

def read_ids1(path)
  s = Set[]
  File.open(path) {|f|
    f.each do |line|
      next if /\A\#\s*define\s+s?reduce_rule/ =~ line
      line.scan(/reduce_rule\((\w+)/) do |event|
        s << event[0]
      end
    end
  }
  ['UNUSED'] + s.to_a + ['MAX_RULES']
end


def generate_eventids2_table(ids, tokens)
  buf = '// DO NOT DIRECTLY EDIT THIS FILE! Autogenerated by tools/generate.rb --ids2src'
  buf << %Q[static void\n]
  buf << %Q[redtree_init_eventids2_table(VALUE self)\n]
  buf << %Q[{\n]
  buf << %Q[    VALUE h = rb_hash_new();\n]
  buf << %Q[    ID id;\n]
  buf << %Q[    rb_aTokenNames = rb_ary_new2(#{tokens.last});\n]
  buf << %Q[    rb_define_const(rb_cToken, "NAMES", rb_aTokenNames);\n]
  tokens.each do |token|
    buf << %Q[    rb_ary_store(rb_aTokenNames, #{token}, ID2SYM(rb_intern_const("#{token.gsub(%q['\n'], 'NL')}")));\n]
  end
  buf << %Q[    rb_define_const(self, "SCANNER_EVENT_TABLE", h);\n]
  ids.each do |id|
    buf << %Q[    id = rb_intern_const("#{id}");\n]
    buf << %Q[    rb_hash_aset(h, ID2SYM(id), INT2NUM(1));\n]
  end
  buf << %Q[}\n]
  buf
end

def read_ids2(path)
  File.open(path) {|f|
    return f.read.scan(/redtree_id_(\w+)/).flatten.uniq.sort
  }
end

def read_tokens(path)
  File.open(path) {|f|
    return f.read.scan(/ *\{([\w]+|'(?:\\n|.)')/).flatten.uniq[0..-2]
  }
end

def read_ripper_ids(path)
  strip_locations(read_ripper_ids_with_locations(path))
end

def strip_locations(h)
  h.map {|event, list| [event, list.first[1]] }\
      .sort_by {|event, arity| event.to_s }
end

def check_arity(h)
  invalid = false
  h.each do |event, list|
    unless list.map {|line, arity| arity }.uniq.size == 1
      invalid = true
      locations = list.map {|line, a| "#{line}:#{a}" }.join(', ')
      $stderr.puts "arity crash [event=#{event}]: #{locations}"
    end
  end
  abort if invalid
end

def read_ripper_ids_with_locations(path)
  h = {}
  File.open(path) {|f|
    f.each do |line|
      next if /\A\#\s*define\s+s?dispatch/ =~ line
      next if /ripper_dispatch/ =~ line
      line.scan(/dispatch(\d)\((\w+)/) do |arity, event|
        (h[event] ||= []).push [f.lineno, arity.to_i]
      end
    end
  }
  h
end

main
