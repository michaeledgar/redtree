# $Id: generate.rb 25189 2009-10-02 12:04:37Z akr $

require 'optparse'
require 'set'

def main
  mode = nil
  ids1src = nil
  ids2src = nil
  template = nil
  output = nil

  parser = @parser = OptionParser.new
  parser.banner = "Usage: #{File.basename($0)} --mode=MODE [--ids1src=PATH] [--output=PATH]"
  parser.on('--mode=MODE', 'check, eventids1.') {|m|
    mode = m
  }
  parser.on('--ids1src=PATH', 'A source file of event-IDs 1 (parse.y).') {|path|
    ids1src = path
  }
  parser.on('--ids2src=PATH', 'A source file of event-IDs 2 (eventids2.c).') {|path|
    ids2src = path
  }
  parser.on('--output=PATH', 'An output file.') {|path|
    output = path
  }
  parser.on('--help', 'Prints this message and quit.') {
    puts parser.help
    exit true
  }
  begin
    parser.parse!
  rescue OptionParser::ParseError => err
    usage err.message
  end
  usage 'no mode given' unless mode
  case mode
  when 'check'
    usage 'no --ids1src' unless ids1src
    h = read_ids1(ids1src)
    ids2 = read_ids2(ids2src)
    common = h & ids2
    unless common.empty?
      abort "event crash: #{common.join(' ')}"
    end
    exit 0
  when 'eventids1'
    usage 'no --ids1src' unless ids1src
    result = generate_eventids1(read_ids1(ids1src))
  when 'eventids2table'
    usage 'no --ids2src' unless ids2src
    result = generate_eventids2_table(read_ids2(ids2src), read_tokens(ids2src))
  end
  if output
    File.open(output, 'w') {|f|
      f.write result
    }
  else
    puts result
  end
end

def usage(msg)
  $stderr.puts msg
  $stderr.puts @parser.help
  exit false
end

def camelize(lower_case_and_underscored_word)
  lower_case_and_underscored_word.to_s.gsub(/\/(.?)/) { "::#{$1.upcase}" }.gsub(/(?:^|_)(.)/) { $1.upcase }
end

def constant_name_for_id(id)
  id.split('__').map { |part| camelize(part) }.join('_')
end

def generate_eventids1(ids)
  buf = "// DO NOT DIRECTLY EDIT THIS FILE! Autogenerated by tools/generate.rb --ids1src\n"
  buf << "enum redtree_ids {\n"
  ids.each do |id|
    buf << "  redtree_rulenum_#{id},\n"
  end
  buf << "};\n\n"
  buf << "static void\n"
  buf << "redtree_init_eventids1(VALUE self) {\n"
  buf << %Q[  rb_aNames = rb_ary_new2(redtree_rulenum_MAX_RULES);\n]
  buf << %Q[  rb_define_const(rb_cNode, "NAMES", rb_aNames);\n]

  ids.each do |id|
    constant_name = constant_name_for_id(id)
    buf << %Q[  rb_define_const(rb_cNode, "#{constant_name}", INT2FIX(redtree_rulenum_#{id}));\n]
    buf << %Q[  rb_ary_push(rb_aNames, ID2SYM(rb_intern_const("#{constant_name}")));\n]
  end

  buf << "}\n"
  buf
end

def read_ids1(path)
  s = Set[]
  File.open(path) {|f|
    f.each do |line|
      next if /\A\#\s*define\s+s?reduce_rule/ =~ line
      line.scan(/reduce_rule\((\w+)/) do |event|
        s << event[0]
      end
    end
  }
  ['UNUSED'] + s.to_a + ['MAX_RULES']
end


def generate_eventids2_table(ids, tokens)
  buf = '// DO NOT DIRECTLY EDIT THIS FILE! Autogenerated by tools/generate.rb --ids2src'
  buf << %Q[static void\n]
  buf << %Q[redtree_init_eventids2_table(VALUE self)\n]
  buf << %Q[{\n]
  buf << %Q[    VALUE h = rb_hash_new();\n]
  buf << %Q[    ID id;\n]
  buf << %Q[    rb_aTokenNames = rb_ary_new2(#{tokens.last});\n]
  buf << %Q[    rb_define_const(rb_cToken, "NAMES", rb_aTokenNames);\n]
  tokens.each do |token|
    buf << %Q[    rb_ary_store(rb_aTokenNames, #{token}, ID2SYM(rb_intern_const("#{token.gsub(%q['\n'], 'NL')}")));\n]
  end
  buf << %Q[    rb_define_const(self, "SCANNER_EVENT_TABLE", h);\n]
  ids.each do |id|
    buf << %Q[    id = rb_intern_const("#{id}");\n]
    buf << %Q[    rb_hash_aset(h, ID2SYM(id), INT2NUM(1));\n]
  end
  buf << %Q[}\n]
  buf
end

def read_ids2(path)
  File.open(path) {|f|
    return f.read.scan(/redtree_id_(\w+)/).flatten.uniq.sort
  }
end

def read_tokens(path)
  File.open(path) {|f|
    return f.read.scan(/ *\{([\w]+|'(?:\\n|.)')/).flatten.uniq[0..-2]
  }
end
main
